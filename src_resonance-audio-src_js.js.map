{"version":3,"file":"src_resonance-audio-src_js.js","mappings":";;;;;;;;AAAA;AACA,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,gFAAiB;AACpD,QAAQ,4BAA4B,EAAE,mBAAO,CAAC,+BAAS;;AAEvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,gBAAgB;AAC3B,YAAY,gBAAgB;AAC5B,YAAY,gCAAgC;AAC5C,gBAAgB,gCAAgC;AAChD,YAAY,mEAAmE;AAC/E,mBAAmB,oEAAoE;AACvF,mBAAmB,oEAAoE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,oEAAoE;AACvF;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB,wEAAwE;AACxF,gBAAgB,wEAAwE;AACxF,iBAAiB;AACjB,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iCAAiC;AAC5E;AACA;AACA,8CAA8C,oCAAoC;AAClF;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,iCAAiC;AACxE;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,4EAA4E;;AAE5E;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,yEAAyE,kBAAkB;AAC3F,GAAG;;AAEH;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,8BAA8B;AAC3C,aAAa,UAAU;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,0CAA0C;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,iBAAiB;AACjB;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC","sources":["webpack://aframe-resonance-audio-component/./src/resonance-audio-src.js"],"sourcesContent":["/* global document, AFRAME, THREE, MediaStream, HTMLMediaElement */\nconst { ResonanceAudio } = require('resonance-audio')\nconst { isVec3Set, onceWhenLoaded } = require('./utils')\n\nconst warn = AFRAME.utils.debug('components:resonance-audio-src:warn')\n\n/**\n * The Object3D name of the visualization.\n */\nconst visName = 'audio-src'\n\nAFRAME.registerComponent('resonance-audio-src', {\n  dependencies: ['position', 'rotation'],\n\n  schema: {\n    src: { type: 'string' }, // asset parsing is taken over from A-Frame.\n    room: { type: 'string' },\n    loop: { type: 'boolean', default: true },\n    autoplay: { type: 'boolean', default: true },\n    gain: { type: 'number', default: ResonanceAudio.Utils.DEFAULT_SOURCE_GAIN },\n    maxDistance: { type: 'number', default: ResonanceAudio.Utils.DEFAULT_MAX_DISTANCE },\n    minDistance: { type: 'number', default: ResonanceAudio.Utils.DEFAULT_MIN_DISTANCE },\n    directivityPattern: {\n      type: 'vec2',\n      default: {\n        x: ResonanceAudio.Utils.DEFAULT_DIRECTIVITY_ALPHA,\n        y: ResonanceAudio.Utils.DEFAULT_DIRECTIVITY_SHARPNESS\n      }\n    },\n    sourceWidth: { type: 'number', default: ResonanceAudio.Utils.DEFAULT_SOURCE_WIDTH },\n    rolloff: {\n      type: 'string',\n      oneOff: ResonanceAudio.Utils.ATTENUATION_ROLLOFFS,\n      default: ResonanceAudio.Utils.DEFAULT_ATTENUATION_ROLLOFF\n    },\n    position: { type: 'vec3', default: new THREE.Vector3(Infinity, Infinity, Infinity) },\n    rotation: { type: 'vec3', default: new THREE.Vector3(Infinity, Infinity, Infinity) },\n    visualize: { type: 'boolean', default: false }\n  },\n\n  init () {\n    // The room this audio source is in.\n    this.room = null\n    // The connection status.\n    this.connected = {\n      element: false,\n      stream: false\n    }\n    // The current connected element or stream.\n    this.sound = null\n\n    // The Resonance audio source.\n    this.resonance = null\n\n    // The default audio element used when src is set to a resource string.\n    this.defaultAudioEl = null\n\n    // A mapping of elements and stream to their source AudioNode objects.\n    // We use a mapping so the created MediaElementAudioSourceNode and MediaStreamAudioSourceNode\n    // objects can be reused.\n    this.mediaAudioSourceNodes = new Map()\n\n    // Update on entity change.\n    this.onEntityChange = this.onEntityChange.bind(this)\n    this.el.addEventListener('componentchanged', this.onEntityChange)\n  },\n\n  update (oldData) {\n    if (this.room && oldData.src !== this.data.src) {\n      this.connectSrc(this.data.src)\n    }\n    this.el.sceneEl.object3D.updateMatrixWorld(true)\n    this.updateSoundSettings()\n    this.updatePlaybackSettings()\n    this.toggleShowVisualization(oldData.visualize, this.data.visualize)\n    this.updateResonancePosition().updateVisualization()\n\n    const roomEl = this.getRoomChoice()\n  \n    if ((roomEl && roomEl.components && roomEl.components['resonance-audio-room']) !== this.room) {\n      /**\n       * Yes, this looks ugly. And this approach has a reason. The audio source needs the audio\n       * room's matrixWorld to calculate the audio source's position relative to the room. This\n       * means scene and the audio room have to be loaded (which they havent on the initial\n       * update).\n       */\n      onceWhenLoaded(this.el.sceneEl, () => {\n        const roomLeft = this.leaveRoom()\n        const roomEntered = this.enter(roomEl)\n        this.connectSrc(this.data.src)\n        this.updateSoundSettings()\n        this.el.sceneEl.object3D.updateMatrixWorld(true)\n        this.updateResonancePosition().updateVisualization()\n        if (roomLeft) {\n          this.el.emit('audioroom-left', { src: this.el, room: roomLeft.el })\n        }\n        if (roomEntered) {\n          this.el.emit('audioroom-entered', { src: this.el, room: roomEntered.el })\n        }\n      })\n    }\n  },\n\n  remove () {\n    this.el.removeEventListener('componentchanged', this.onEntityChange)\n    this.disconnect()\n    const roomLeft = this.leaveRoom()\n    this.toggleShowVisualization(this.data.visualize, false)\n\n    if (roomLeft) {\n      this.el.emit('audioroom-left', { src: this.el, room: roomLeft.el })\n    }\n  },\n\n  /**\n   * Update the Resonance sound settings.\n   */\n  updateSoundSettings () {\n    const s = this.resonance\n    if (!s) { return }\n    s.setGain(this.data.gain)\n    s.setMinDistance(this.data.minDistance)\n    s.setMaxDistance(this.data.maxDistance)\n    s.setDirectivityPattern(this.data.directivityPattern.x, this.data.directivityPattern.y)\n    s.setSourceWidth(this.data.sourceWidth)\n    s.setRolloff(this.data.rolloff)\n  },\n\n  /**\n   * Update the playback settings.\n   */\n  updatePlaybackSettings () {\n    if (!this.connected.element) { return }\n\n    // Update loop.\n    if (this.data.loop) {\n      this.sound.setAttribute('loop', 'true')\n    } else {\n      this.sound.removeAttribute('loop')\n    }\n    // Update autoplay.\n    if (this.data.autoplay) {\n      this.sound.setAttribute('autoplay', 'true')\n    } else {\n      this.sound.removeAttribute('autoplay')\n    }\n  },\n\n  /**\n   * Update the position in Google Resonance of this audio source, so relative to the audio room.\n   * @returns {this}\n   */\n  updateResonancePosition () {\n    if (this.resonance) {\n      this.resonance.setFromMatrix(this.getMatrixRoom())\n    }\n    return this\n  },\n\n  /**\n   * Toggle showing the visualization.\n   * @param {boolean} previous - the previous setting\n   * @param {boolean} current - the new setting\n   */\n  toggleShowVisualization (previous, current) {\n    if (!previous && current) {\n      this.el.setObject3D(\n        visName,\n        new THREE.Mesh(\n          new THREE.SphereBufferGeometry(this.data.minDistance, 36, 18),\n          new THREE.MeshStandardMaterial({\n            color: 0xffffff,\n            metalness: 0,\n            wireframe: true,\n            visible: true\n          })\n        )\n      )\n    } else if (previous && !current && this.el.getObject3D(visName)) {\n      this.el.removeObject3D(visName)\n    }\n  },\n\n  /**\n   * Update the visualization's position, orientation and shape.\n   * @returns {this}\n   */\n  updateVisualization () {\n    const d = this.data\n    let v = this.el.getObject3D(visName)\n    if (d.visualize && v) {\n      // If appearance changed, redraw.\n      if (v.geometry.parameters.radius !== this.data.minDistance) {\n        this.toggleShowVisualization(true, false)\n        this.toggleShowVisualization(false, true)\n        v = this.el.getObject3D(visName)\n      }\n      const m = this.getMatrixLocal()\n      v.position.setFromMatrixPosition(m)\n      v.quaternion.setFromRotationMatrix(m)\n      v.material.color.setHex(this.room ? 0xffffff : 0xff0000)\n      v.matrixWorldNeedsUpdate = true\n    }\n    return this\n  },\n\n  /**\n   * When the entity's position or rotation is changed, update the Resonance audio position and\n   * visualization accordingly.\n   * @param {Event} evt\n   */\n  onEntityChange (evt) {\n    if (evt.detail.name !== 'position' && evt.detail.name !== 'rotation') { return }\n\n    this.el.sceneEl.object3D.updateMatrixWorld(true)\n    this.updateResonancePosition().updateVisualization()\n  },\n\n  /**\n   * Get the choice of audio Room. Checking order of room property:\n   * - value is falsey: parent node is returned. This prevents using an empty string as query selector.\n   * - value is an A-Frame entity: entity is returned.\n   * - value is a string: document.querySelector result is returned. This might be null.\n   * - else: parent node is returned.\n   * @returns {HTMLElement|null}\n   */\n  getRoomChoice () {\n    const ar = this.data.room\n    return !ar\n      ? this.el.parentNode\n      : ar instanceof AFRAME.AEntity\n        ? ar\n        : typeof ar === 'string'\n          ? document.querySelector(ar)\n          : this.el.parentNode\n  },\n\n  /**\n   * Get a copy of the matrixWorld of the audio source, taking into account any custom set position\n   * or rotation, in world coordinates.\n   * @return {THREE.Matrix4}\n   */\n  getMatrixWorld () {\n    if (!isVec3Set(this.data.position) && !isVec3Set(this.data.rotation)) {\n      // No custom position or rotation was set, so simply return a copy of the matrixWorld of the\n      // current entity.\n      return new THREE.Matrix4().copy(this.el.object3D.matrixWorld)\n    } else {\n      // Return matrixWorld calculated by multiplying the parent's matrixWorld and the local\n      // matrix, as Three.js's Object3D.updateMatrixWorld() basically does.\n      return new THREE.Matrix4().multiplyMatrices(\n        this.el.parentNode.object3D.matrixWorld,\n        this.getMatrixLocalCustom()\n      )\n    }\n  },\n\n  /**\n   * Get the matrix in local coordinates. The position and rotation attributes (individually)\n   * take precedence over any position and rotation components set on the current entity. The\n   * scale is 1.\n   * @returns {THREE.Matrix4}\n   */\n  getMatrixLocalCustom () {\n    let localPosition, localQuaternion\n\n    if (isVec3Set(this.data.position)) {\n      localPosition = new THREE.Vector3(this.data.position.x, this.data.position.y, this.data.position.z)\n    } else {\n      localPosition = this.el.object3D.position\n    }\n\n    if (isVec3Set(this.data.rotation)) {\n      let radians = [this.data.rotation.x, this.data.rotation.y, this.data.rotation.z].map(THREE.Math.degToRad)\n      localQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler().reorder('YXZ').fromArray(radians))\n    } else {\n      localQuaternion = this.el.object3D.quaternion\n    }\n\n    return new THREE.Matrix4().compose(localPosition, localQuaternion, { x: 1, y: 1, z: 1 })\n  },\n\n  /**\n   * Get a matrix of the audio source's position and rotation relative to the audio room, taking\n   * into account any custom set position or rotation.\n   * @returns {THREE.Matrix4}\n   */\n  getMatrixRoom () {\n    return this.getMatrixWorld().premultiply(\n      new THREE.Matrix4().copy(this.room.el.object3D.matrixWorld).invert()\n    )\n  },\n\n  /**\n   * Get a matrix of position and rotation relative to its owner entity, taking into account any\n   * custom set position or rotation.\n   * @returns {THREE.Matrix4}\n   */\n  getMatrixLocal () {\n    return this.getMatrixWorld().premultiply(\n      new THREE.Matrix4().copy(this.el.object3D.matrixWorld).invert()\n    )\n  },\n\n  /**\n   * Enter an audio room. If the passed audio room has no resonance-audio-room component, show a\n   * warning and return false.\n   * @param {AFRAME.AEntity} roomEl - the room element\n   * @returns {AFRAME.AComponent|boolean} the entered room component or false if it couldn't be\n   *                                      entered\n   */\n  enter (roomEl) {\n    if (!roomEl || !roomEl.components || !('resonance-audio-room' in roomEl.components)) {\n      warn(\"can't enter audio room because it is no audio room\")\n      return false\n    }\n\n    // Store references to each other.\n    this.room = roomEl.components['resonance-audio-room']\n    this.room.store(this.el)\n\n    // Create Resonance source.\n    this.resonance = this.room.resonanceAudioScene.createSource()\n\n    // Prepare default audio element.\n    this.defaultAudioEl = document.createElement('audio')\n    this.mediaAudioSourceNodes.set(\n      this.defaultAudioEl, this.room.audioContext.createMediaElementSource(this.defaultAudioEl)\n    )\n    return this.room\n  },\n\n  /**\n   * Leave the audio room if this audio source is in one.\n   * @returns {AFRAME.AComponent|boolean} the room that was left or false if there was no room to leave\n   */\n  leaveRoom () {\n    if (!this.room) { return false }\n    const room = this.room\n    this.room.forget(this.el)\n    this.room = null\n\n    this.resonance = null\n    this.mediaAudioSourceNodes.delete(this.defaultAudioEl)\n    this.defaultAudioEl = null\n\n    return room\n  },\n\n  /**\n   * Connect a HTMLMediaElement or MediaStream to the room's AudioContext.\n   * @param {HTMLMediaElement|MediaStream} source - the audio source\n   * @param {function} createSourceFn - the function that creates an AudioSourceNode based on the passed source\n   * @returns {boolean} false if there was not source to connect\n   */\n  connect (source, createSourceFn) {\n    // Don't connect a new source if there is none.\n    if (!source) { return false }\n\n    this.sound = source\n\n    // Create new source AudioNode if source object didn't have one yet.\n    if (!this.mediaAudioSourceNodes.has(this.sound)) {\n      this.mediaAudioSourceNodes.set(this.sound, createSourceFn.call(this.room.audioContext, this.sound))\n    }\n    // Get elemenent source AudioNode.\n    this.mediaAudioSourceNodes.get(this.sound).connect(this.resonance.input)\n\n    return true\n  },\n\n  /**\n   * Connect a media element to this resonance-audio-src.\n   * @param {HTMLMediaElement} el - the media element\n   */\n  connectWithElement (el) {\n    this.connected.element = this.connect(el, this.room.audioContext.createMediaElementSource)\n\n    if (!this.connected.element) { return }\n    // Warn when an element with a stream was connected.\n    if (this.sound.srcObject) {\n      warn(\"can't use a HTMLMediaElement that contains a stream. Connect the stream itself.\")\n    }\n    // Apply playback settings.\n    this.updatePlaybackSettings() // TODO this shouldn't be here\n    // Play the audio.\n    if (this.sound.getAttribute('autoplay')) {\n      this.sound.play().then().catch(w => warn(w))\n    }\n  },\n\n  /**\n   * Connect a stream to this resonance-audio-src.\n   * @param {MediaStream} stream - the stream\n   */\n  connectWithStream (stream) {\n    this.connected.stream = this.connect(stream, this.room.audioContext.createMediaStreamSource)\n\n    if (!this.connected.stream) { return }\n    // Add play/pause API to sound that give a warning when accessed.\n    const unavailable = () => warn(\"can't use play/pause on MediaStream. Manipulate the stream's source instead\")\n    this.sound.play = unavailable\n    this.sound.pause = unavailable\n  },\n\n  /**\n   * Disconnect HTMLMediaElement or MediaStream from this resonance-audio-src.\n   */\n  disconnect () {\n    if (this.sound && this.resonance) {\n      this.mediaAudioSourceNodes.get(this.sound).disconnect(this.resonance.input)\n      this.sound = null\n    }\n    this.connected.element = false\n    this.connected.stream = false\n  },\n\n  /**\n   * Set a new source.\n   * @param {string|HTMLMediaElement|MediaStream|null} src\n   */\n  connectSrc (src) {\n    const errorMsg = 'invalid src value. Must be element id string, resource string, HTMLMediaElement or MediaStream'\n\n    this.disconnect()\n    let el\n    if (!src) {\n      // Do nothing, because we've already disconnected.\n    } else if (src instanceof MediaStream) {\n      this.connectWithStream(src)\n    } else if (src instanceof HTMLMediaElement) {\n      this.connectWithElement(src)\n    } else if (typeof src === 'string') {\n      if (src.charAt(0) === '#') {\n        el = document.getElementById(src.substr(1))\n      } else {\n        el = this.defaultAudioEl\n        el.setAttribute('src', src)\n      }\n      if (!el) { throw new TypeError(errorMsg) }\n      this.connectWithElement(el)\n    } else {\n      throw new TypeError(errorMsg)\n    }\n    this.data.src = el || src\n  }\n})\n\nAFRAME.registerPrimitive('a-resonance-audio-src', {\n  defaultComponents: {\n    'resonance-audio-src': {}\n  },\n  mappings: {\n    src: 'resonance-audio-src.src',\n    room: 'resonance-audio-src.room',\n    loop: 'resonance-audio-src.loop',\n    autoplay: 'resonance-audio-src.autoplay',\n\n    gain: 'resonance-audio-src.gain',\n    'min-distance': 'resonance-audio-src.minDistance',\n    'max-distance': 'resonance-audio-src.maxDistaonce',\n    'directivity-pattern': 'resonance-audio-src.directivityPattern',\n    'source-width': 'resonance-audio-src.sourceWidth',\n    rolloff: 'resonance-audio-src.rolloff',\n    // The orientation and position are set by the rotation and position components, respectively.\n\n    visualize: 'resonance-audio-src.visualize'\n  }\n})\n"],"names":[],"sourceRoot":""}